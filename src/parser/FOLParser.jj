//
// Generated by JTB 1.3.2
//



PARSER_BEGIN(TALParser)
package parser;

import parser.syntaxtree.*;
import java.util.Vector;


public class TALParser 
{
}

class JTBToolkit {
   static NodeToken makeNodeToken(Token t) {
      return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
   }
}


PARSER_END(TALParser)

SKIP :
{
   " "
   | "\r"
   | "\t"
   | "\n"
}

TOKEN :
{
   <LPAR: "(">
   | <RPAR: ")">
   | <COMMA: ",">
   | <SEMICOLON: ";">
   | <COLON: ":">
   | <LBRACK: "[">
   | <RBRACK: "]">
}

TOKEN :
{
   <OR: "or">
   | <AND: "and">
   | <NOT: "not">
   | <EXISTS: "exists">
   | <FORALL: "forall">
   | <IMPLIC: "->">
   | <EQUIV: "<->">
}

TOKEN :
{
   <IDENT: ["a"-"z"] (["a"-"z"] | ["A"-"Z"] | ["0"-"9"])*>
   | <VAR: ["A"-"Z"] (["a"-"z"] | ["A"-"Z"] | ["0"-"9"])*>
   | <NUM: (["0"-"9"])+>
}

one_line one_line() :
{
   fof n0;
   NodeToken n1;
   Token n2;

   
}
{
   n0=fof()
   n2=<EOF> { 
      n2.beginColumn++; n2.endColumn++;
      n1 = JTBToolkit.makeNodeToken(n2);
   }
   
   { return new one_line(n0,n1); }
}

fof fof() :
{
   implication n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   implication n5;

   
}
{
   n0=implication()
   (
      { n2 = new NodeSequence(2); }
      n4=<EQUIV> { n3 = JTBToolkit.makeNodeToken(n4); }
      { n2.addNode(n3); }
      n5=implication()
      { n2.addNode(n5); }
      { n1.addNode(n2); }
   )*
   { n1.nodes.trimToSize(); }
   
   { return new fof(n0,n1); }
}

implication implication() :
{
   disjunction n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   disjunction n5;

   
}
{
   n0=disjunction()
   (
      { n2 = new NodeSequence(2); }
      n4=<IMPLIC> { n3 = JTBToolkit.makeNodeToken(n4); }
      { n2.addNode(n3); }
      n5=disjunction()
      { n2.addNode(n5); }
      { n1.addNode(n2); }
   )*
   { n1.nodes.trimToSize(); }
   
   { return new implication(n0,n1); }
}

disjunction disjunction() :
{
   conjunction n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   conjunction n5;

   
}
{
   n0=conjunction()
   (
      { n2 = new NodeSequence(2); }
      n4=<OR> { n3 = JTBToolkit.makeNodeToken(n4); }
      { n2.addNode(n3); }
      n5=conjunction()
      { n2.addNode(n5); }
      { n1.addNode(n2); }
   )*
   { n1.nodes.trimToSize(); }
   
   { return new disjunction(n0,n1); }
}

conjunction conjunction() :
{
   unary n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   unary n5;

   
}
{
   n0=unary()
   (
      { n2 = new NodeSequence(2); }
      n4=<AND> { n3 = JTBToolkit.makeNodeToken(n4); }
      { n2.addNode(n3); }
      n5=unary()
      { n2.addNode(n5); }
      { n1.addNode(n2); }
   )*
   { n1.nodes.trimToSize(); }
   
   { return new conjunction(n0,n1); }
}

unary unary() :
{
   NodeChoice n0;
   literal n1;
   quantification n2;

   
}
{
   (
      n1=literal()
      { n0 = new NodeChoice(n1, 0); }
   |
      n2=quantification()
      { n0 = new NodeChoice(n2, 1); }
   )
   
   { return new unary(n0); }
}

quantification quantification() :
{
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   unary n9;

   
}
{
   (
      (
         n2=<EXISTS> { n1 = JTBToolkit.makeNodeToken(n2); }
         { n0 = new NodeChoice(n1, 0); }
      |
         n4=<FORALL> { n3 = JTBToolkit.makeNodeToken(n4); }
         { n0 = new NodeChoice(n3, 1); }
      )
      
   )
   n6=<VAR> { n5 = JTBToolkit.makeNodeToken(n6); }
   n8=<COLON> { n7 = JTBToolkit.makeNodeToken(n8); }
   n9=unary()
   
   { return new quantification(n0,n5,n7,n9); }
}

literal literal() :
{
   NodeChoice n0;
   atom n1;
   negation n2;

   
}
{
   (
      n1=atom()
      { n0 = new NodeChoice(n1, 0); }
   |
      n2=negation()
      { n0 = new NodeChoice(n2, 1); }
   )
   
   { return new literal(n0); }
}

negation negation() :
{
   NodeToken n0;
   Token n1;
   unary n2;

   
}
{
   n1=<NOT> { n0 = JTBToolkit.makeNodeToken(n1); }
   n2=unary()
   
   { return new negation(n0,n2); }
}

atom atom() :
{
   NodeChoice n0;
   terminal n1;
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   fof n5;
   NodeToken n6;
   Token n7;
   NodeSequence n8;
   NodeToken n9;
   Token n10;
   fof n11;
   NodeToken n12;
   Token n13;

   
}
{
   (
      n1=terminal()
      { n0 = new NodeChoice(n1, 0); }
   |
      { n2 = new NodeSequence(3); }
      n4=<LPAR> { n3 = JTBToolkit.makeNodeToken(n4); }
      { n2.addNode(n3); }
      n5=fof()
      { n2.addNode(n5); }
      n7=<RPAR> { n6 = JTBToolkit.makeNodeToken(n7); }
      { n2.addNode(n6); }
      { n0 = new NodeChoice(n2, 1); }
   |
      { n8 = new NodeSequence(3); }
      n10=<LBRACK> { n9 = JTBToolkit.makeNodeToken(n10); }
      { n8.addNode(n9); }
      n11=fof()
      { n8.addNode(n11); }
      n13=<RBRACK> { n12 = JTBToolkit.makeNodeToken(n13); }
      { n8.addNode(n12); }
      { n0 = new NodeChoice(n8, 2); }
   )
   
   { return new atom(n0); }
}

terminal terminal() :
{
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   predicate n3;

   
}
{
   (
      n2=<VAR> { n1 = JTBToolkit.makeNodeToken(n2); }
      { n0 = new NodeChoice(n1, 0); }
   |
      n3=predicate()
      { n0 = new NodeChoice(n3, 1); }
   )
   
   { return new terminal(n0); }
}

predicate predicate() :
{
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   argblock n3;

   
}
{
   n1=<IDENT> { n0 = JTBToolkit.makeNodeToken(n1); }
   (
      n3=argblock()
      { n2.addNode(n3); }
   )?
   
   { return new predicate(n0,n2); }
}

argblock argblock() :
{
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   args n3;
   NodeToken n4;
   Token n5;

   
}
{
   n1=<LPAR> { n0 = JTBToolkit.makeNodeToken(n1); }
   (
      n3=args()
      { n2.addNode(n3); }
   )?
   n5=<RPAR> { n4 = JTBToolkit.makeNodeToken(n5); }
   
   { return new argblock(n0,n2,n4); }
}

args args() :
{
   arg n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   arg n5;

   
}
{
   n0=arg()
   (
      { n2 = new NodeSequence(2); }
      n4=<COMMA> { n3 = JTBToolkit.makeNodeToken(n4); }
      { n2.addNode(n3); }
      n5=arg()
      { n2.addNode(n5); }
      { n1.addNode(n2); }
   )*
   { n1.nodes.trimToSize(); }
   
   { return new args(n0,n1); }
}

arg arg() :
{
   NodeChoice n0;
   predicate n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;

   
}
{
   (
      LOOKAHEAD(<IDENT> <LPAR>)
      n1=predicate()
      { n0 = new NodeChoice(n1, 0); }
   |
      n3=<IDENT> { n2 = JTBToolkit.makeNodeToken(n3); }
      { n0 = new NodeChoice(n2, 1); }
   |
      n5=<VAR> { n4 = JTBToolkit.makeNodeToken(n5); }
      { n0 = new NodeChoice(n4, 2); }
   |
      n7=<NUM> { n6 = JTBToolkit.makeNodeToken(n7); }
      { n0 = new NodeChoice(n6, 3); }
   )
   
   { return new arg(n0); }
}
